/*
 * Copyright 2022-2025 openDAQ d.o.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
//     RTGen (CSharpGenerator v1.0.0) on 15.05.2025 12:01:32.
// </auto-generated>
//------------------------------------------------------------------------------


namespace Daq.Core.Types;


[StructLayout(LayoutKind.Sequential)]
internal unsafe class RawSearchFilter : RawBaseObject
{
    //ErrorCode acceptsObject(daq.IBaseObject* obj, daq.Bool* accepts); stdcall;
    public delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out bool, ErrorCode> AcceptsObject;
    //ErrorCode visitChildren(daq.IBaseObject* obj, daq.Bool* visit); stdcall;
    public delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out bool, ErrorCode> VisitChildren;
}

/// <summary>
/// Search filter that can be passed as an optional parameter to search functions to filter
/// out unwanted results. Allows for recursive searches.
/// </summary>
/// <remarks>
/// Each filter defines an &quot;accepts object&quot; and &quot;visit children&quot; function.
/// <para/>
/// Accepts object defines whether or not the object being evaluated as part of a search method should be included
/// in the resulting output.
/// <para/>
/// Visit children defines whether or not the children of said object should be traversed during a recursive search.
/// </remarks>
[Guid("d622d434-e089-58ce-8305-bd44b16b8f35")]
public class SearchFilter : BaseObject
{
    //type-casted base._virtualTable
    private readonly RawSearchFilter _rawSearchFilter;

    internal SearchFilter(IntPtr nativePointer, bool incrementReference)
        : base(nativePointer, incrementReference)
    {
        IntPtr objVirtualTable = Marshal.ReadIntPtr(nativePointer, 0); //read the pointer from the given address
        base._virtualTable =
            _rawSearchFilter = Marshal.PtrToStructure<RawSearchFilter>(objVirtualTable);
    }

    /// <summary>Defines whether or not the object should be included in the search results</summary>
    /// <param name="obj">The object being evaluated.</param>
    /// <returns>True of the object is to be included in the results; false otherwise.</returns>
    public bool AcceptsObject(BaseObject obj)
    {
        //native output argument
        bool accepts;

        unsafe //use native function pointer
        {
            //call native function
            ErrorCode errorCode = (ErrorCode)_rawSearchFilter.AcceptsObject(base.NativePointer, obj, out accepts);

            if (Result.Failed(errorCode))
            {
                throw new OpenDaqException(errorCode);
            }
        }

        return accepts;
    }

    /// <summary>Defines whether or not the children of said object should be traversed during a recursive search.</summary>
    /// <param name="obj">The object being evaluated.</param>
    /// <returns>True of the object&apos;s children should be traversed; false otherwise.</returns>
    public bool VisitChildren(BaseObject obj)
    {
        //native output argument
        bool visit;

        unsafe //use native function pointer
        {
            //call native function
            ErrorCode errorCode = (ErrorCode)_rawSearchFilter.VisitChildren(base.NativePointer, obj, out visit);

            if (Result.Failed(errorCode))
            {
                throw new OpenDaqException(errorCode);
            }
        }

        return visit;
    }
}


#region Class Factory

// Factory functions of the &apos;CoreTypes&apos; library.
public static partial class CoreTypesFactory
{
    //ErrorCode createAnySearchFilter(daq.ISearchFilter** obj); cdecl;
    [DllImport(CoreTypesDllInfo.FileName, CallingConvention = CallingConvention.Cdecl)]
    private static extern ErrorCode createAnySearchFilter(out IntPtr obj);

    /// <summary>Creates a search filter that accepts all objects. &quot;Visit children&quot; always returns <c>true</c>.</summary>
    /// <param name="obj">The &apos;SearchFilter&apos; object.</param>
    public static ErrorCode CreateAnySearchFilter(out SearchFilter obj)
    {
        //initialize output argument
        obj = default;

        //native output argument
        IntPtr objPtr;

        //call native function
        ErrorCode errorCode = createAnySearchFilter(out objPtr);

        if (Result.Succeeded(errorCode))
        {
            //create object
            obj = new SearchFilter(objPtr, incrementReference: false);
        }

        return errorCode;
    }

    /// <summary>Creates a search filter that accepts all objects. &quot;Visit children&quot; always returns <c>true</c>.</summary>
    /// <returns>The &apos;SearchFilter&apos; object.</returns>
    public static SearchFilter CreateAnySearchFilter()
    {
        //native output argument
        IntPtr objPtr;

        //call native function
        ErrorCode errorCode = createAnySearchFilter(out objPtr);

        if (Result.Failed(errorCode))
        {
            throw new OpenDaqException(errorCode);
        }

        //create and return object
        return new SearchFilter(objPtr, incrementReference: false);
    }


    //ErrorCode createAndSearchFilter(daq.ISearchFilter** obj, daq.ISearchFilter* left, daq.ISearchFilter* right); cdecl;
    [DllImport(CoreTypesDllInfo.FileName, CallingConvention = CallingConvention.Cdecl)]
    private static extern ErrorCode createAndSearchFilter(out IntPtr obj, IntPtr left, IntPtr right);

    /// <summary>
    /// Creates a &quot;conjunction&quot; search filter that combines 2 filters, accepting an object only if both filters accept it.
    /// &quot;Visit children&quot; returns <c>true</c> only if both filters do so.
    /// </summary>
    /// <param name="obj">The &apos;SearchFilter&apos; object.</param>
    /// <param name="left">The first argument of the conjunction operation.</param>
    /// <param name="right">The second argument of the conjunction operation.</param>
    public static ErrorCode CreateAndSearchFilter(out SearchFilter obj, SearchFilter left, SearchFilter right)
    {
        //initialize output argument
        obj = default;

        //native output argument
        IntPtr objPtr;

        //call native function
        ErrorCode errorCode = createAndSearchFilter(out objPtr, left, right);

        if (Result.Succeeded(errorCode))
        {
            //create object
            obj = new SearchFilter(objPtr, incrementReference: false);
        }

        return errorCode;
    }

    /// <summary>
    /// Creates a &quot;conjunction&quot; search filter that combines 2 filters, accepting an object only if both filters accept it.
    /// &quot;Visit children&quot; returns <c>true</c> only if both filters do so.
    /// </summary>
    /// <returns>The &apos;SearchFilter&apos; object.</returns>
    /// <param name="left">The first argument of the conjunction operation.</param>
    /// <param name="right">The second argument of the conjunction operation.</param>
    public static SearchFilter CreateAndSearchFilter(SearchFilter left, SearchFilter right)
    {
        //native output argument
        IntPtr objPtr;

        //call native function
        ErrorCode errorCode = createAndSearchFilter(out objPtr, left, right);

        if (Result.Failed(errorCode))
        {
            throw new OpenDaqException(errorCode);
        }

        //create and return object
        return new SearchFilter(objPtr, incrementReference: false);
    }


    //ErrorCode createOrSearchFilter(daq.ISearchFilter** obj, daq.ISearchFilter* left, daq.ISearchFilter* right); cdecl;
    [DllImport(CoreTypesDllInfo.FileName, CallingConvention = CallingConvention.Cdecl)]
    private static extern ErrorCode createOrSearchFilter(out IntPtr obj, IntPtr left, IntPtr right);

    /// <summary>
    /// Creates a &quot;disjunction&quot; search filter that combines 2 filters, accepting an object if any of the two filters accepts it.
    /// &quot;Visit children&quot; returns <c>true</c> if any of the two filters accepts does so.
    /// </summary>
    /// <param name="obj">The &apos;SearchFilter&apos; object.</param>
    /// <param name="left">The first argument of the disjunction operation.</param>
    /// <param name="right">The second argument of the disjunction operation.</param>
    public static ErrorCode CreateOrSearchFilter(out SearchFilter obj, SearchFilter left, SearchFilter right)
    {
        //initialize output argument
        obj = default;

        //native output argument
        IntPtr objPtr;

        //call native function
        ErrorCode errorCode = createOrSearchFilter(out objPtr, left, right);

        if (Result.Succeeded(errorCode))
        {
            //create object
            obj = new SearchFilter(objPtr, incrementReference: false);
        }

        return errorCode;
    }

    /// <summary>
    /// Creates a &quot;disjunction&quot; search filter that combines 2 filters, accepting an object if any of the two filters accepts it.
    /// &quot;Visit children&quot; returns <c>true</c> if any of the two filters accepts does so.
    /// </summary>
    /// <returns>The &apos;SearchFilter&apos; object.</returns>
    /// <param name="left">The first argument of the disjunction operation.</param>
    /// <param name="right">The second argument of the disjunction operation.</param>
    public static SearchFilter CreateOrSearchFilter(SearchFilter left, SearchFilter right)
    {
        //native output argument
        IntPtr objPtr;

        //call native function
        ErrorCode errorCode = createOrSearchFilter(out objPtr, left, right);

        if (Result.Failed(errorCode))
        {
            throw new OpenDaqException(errorCode);
        }

        //create and return object
        return new SearchFilter(objPtr, incrementReference: false);
    }


    //ErrorCode createNotSearchFilter(daq.ISearchFilter** obj, daq.ISearchFilter* filter); cdecl;
    [DllImport(CoreTypesDllInfo.FileName, CallingConvention = CallingConvention.Cdecl)]
    private static extern ErrorCode createNotSearchFilter(out IntPtr obj, IntPtr filter);

    /// <summary>
    /// Creates a search filter that negates the &quot;accepts object&quot; result of the filter provided as construction argument.
    /// Does not negate the &quot;visit children&quot; result.
    /// </summary>
    /// <param name="obj">The &apos;SearchFilter&apos; object.</param>
    /// <param name="filter">The filter of which results should be negated.</param>
    public static ErrorCode CreateNotSearchFilter(out SearchFilter obj, SearchFilter filter)
    {
        //initialize output argument
        obj = default;

        //native output argument
        IntPtr objPtr;

        //call native function
        ErrorCode errorCode = createNotSearchFilter(out objPtr, filter);

        if (Result.Succeeded(errorCode))
        {
            //create object
            obj = new SearchFilter(objPtr, incrementReference: false);
        }

        return errorCode;
    }

    /// <summary>
    /// Creates a search filter that negates the &quot;accepts object&quot; result of the filter provided as construction argument.
    /// Does not negate the &quot;visit children&quot; result.
    /// </summary>
    /// <returns>The &apos;SearchFilter&apos; object.</returns>
    /// <param name="filter">The filter of which results should be negated.</param>
    public static SearchFilter CreateNotSearchFilter(SearchFilter filter)
    {
        //native output argument
        IntPtr objPtr;

        //call native function
        ErrorCode errorCode = createNotSearchFilter(out objPtr, filter);

        if (Result.Failed(errorCode))
        {
            throw new OpenDaqException(errorCode);
        }

        //create and return object
        return new SearchFilter(objPtr, incrementReference: false);
    }


    //ErrorCode createCustomSearchFilter(daq.ISearchFilter** obj, daq.IFunction* acceptsFunction, daq.IFunction* visitFunction); cdecl;
    [DllImport(CoreTypesDllInfo.FileName, CallingConvention = CallingConvention.Cdecl)]
    private static extern ErrorCode createCustomSearchFilter(out IntPtr obj, IntPtr acceptsFunction, IntPtr visitFunction);

    /// <summary>Creates a custom search filter with a user-defined &quot;accepts object&quot; and &quot;visit children&quot; function.</summary>
    /// <param name="obj">The &apos;SearchFilter&apos; object.</param>
    /// <param name="acceptsFunction">The function to be called when &quot;accepts object&quot; is called. Should return <c>true</c> or <c>false</c>.</param>
    /// <param name="visitFunction">The function to be called when &quot;visit children&quot; is called. Should return <c>true</c> or <c>false</c>.</param>
    public static ErrorCode CreateCustomSearchFilter(out SearchFilter obj, Function acceptsFunction, Function visitFunction)
    {
        //initialize output argument
        obj = default;

        //native output argument
        IntPtr objPtr;

        //call native function
        ErrorCode errorCode = createCustomSearchFilter(out objPtr, acceptsFunction, visitFunction);

        if (Result.Succeeded(errorCode))
        {
            //create object
            obj = new SearchFilter(objPtr, incrementReference: false);
        }

        return errorCode;
    }

    /// <summary>Creates a custom search filter with a user-defined &quot;accepts object&quot; and &quot;visit children&quot; function.</summary>
    /// <returns>The &apos;SearchFilter&apos; object.</returns>
    /// <param name="acceptsFunction">The function to be called when &quot;accepts object&quot; is called. Should return <c>true</c> or <c>false</c>.</param>
    /// <param name="visitFunction">The function to be called when &quot;visit children&quot; is called. Should return <c>true</c> or <c>false</c>.</param>
    public static SearchFilter CreateCustomSearchFilter(Function acceptsFunction, Function visitFunction)
    {
        //native output argument
        IntPtr objPtr;

        //call native function
        ErrorCode errorCode = createCustomSearchFilter(out objPtr, acceptsFunction, visitFunction);

        if (Result.Failed(errorCode))
        {
            throw new OpenDaqException(errorCode);
        }

        //create and return object
        return new SearchFilter(objPtr, incrementReference: false);
    }


    //ErrorCode createRecursiveSearchFilter(daq.ISearchFilter** obj, daq.ISearchFilter* filter); cdecl;
    [DllImport(CoreTypesDllInfo.FileName, CallingConvention = CallingConvention.Cdecl)]
    private static extern ErrorCode createRecursiveSearchFilter(out IntPtr obj, IntPtr filter);

    /// <summary>
    /// Creates a search filter that indicates that the search method should recursively search through the object&apos;s child elements.
    /// This filter constructor should always be the final filter wrapper, and should not be used as a constructor argument
    /// for another filter.
    /// </summary>
    /// <param name="obj">The &apos;SearchFilter&apos; object.</param>
    /// <param name="filter">The filter to be wrapped with a &quot;recursive&quot; flag.</param>
    public static ErrorCode CreateRecursiveSearchFilter(out SearchFilter obj, SearchFilter filter)
    {
        //initialize output argument
        obj = default;

        //native output argument
        IntPtr objPtr;

        //call native function
        ErrorCode errorCode = createRecursiveSearchFilter(out objPtr, filter);

        if (Result.Succeeded(errorCode))
        {
            //create object
            obj = new SearchFilter(objPtr, incrementReference: false);
        }

        return errorCode;
    }

    /// <summary>
    /// Creates a search filter that indicates that the search method should recursively search through the object&apos;s child elements.
    /// This filter constructor should always be the final filter wrapper, and should not be used as a constructor argument
    /// for another filter.
    /// </summary>
    /// <returns>The &apos;SearchFilter&apos; object.</returns>
    /// <param name="filter">The filter to be wrapped with a &quot;recursive&quot; flag.</param>
    public static SearchFilter CreateRecursiveSearchFilter(SearchFilter filter)
    {
        //native output argument
        IntPtr objPtr;

        //call native function
        ErrorCode errorCode = createRecursiveSearchFilter(out objPtr, filter);

        if (Result.Failed(errorCode))
        {
            throw new OpenDaqException(errorCode);
        }

        //create and return object
        return new SearchFilter(objPtr, incrementReference: false);
    }
}

#endregion Class Factory
