//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
//     RTGen (PythonGenerator).
// </auto-generated>
//------------------------------------------------------------------------------

/*
 * Copyright 2022-2025 openDAQ d.o.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <pybind11/gil.h>

#include "py_opendaq/py_opendaq.h"
#include "py_core_types/py_converter.h"
#include "py_core_objects/py_variant_extractor.h"
#include "py_opendaq/py_typed_reader.h"

PyDaqIntf<daq::IMultiReaderBuilder, daq::IBaseObject> declareIMultiReaderBuilder(pybind11::module_ m)
{
    return wrapInterface<daq::IMultiReaderBuilder, daq::IBaseObject>(m, "IMultiReaderBuilder");
}

void defineIMultiReaderBuilder(pybind11::module_ m, PyDaqIntf<daq::IMultiReaderBuilder, daq::IBaseObject> cls)
{
    cls.doc() = "Builder component of Multi reader objects. Contains setter methods to configure the Multi reader parameters and a `build` method that builds the Unit object.";

    m.def("MultiReaderBuilder", &daq::MultiReaderBuilder_Create);

    cls.def("build",
        [](daq::IMultiReaderBuilder *object)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
			auto domainReadType = objectPtr.getDomainReadType();
			PyTypedReader::checkTypes(objectPtr.getValueReadType(), domainReadType);
			if(domainReadType == daq::SampleType::Undefined)
				throw daq::InvalidParameterException("Domain type cannot be undefined.");
            return objectPtr.build().detach();
        },
        "Builds and returns a Multi reader object using the currently set values of the Builder.");
    cls.def("add_signal",
        [](daq::IMultiReaderBuilder *object, daq::ISignal* signal)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            objectPtr.addSignal(signal);
        },
        py::arg("signal"),
        "Adds a signal that will be read by the multi reader");
    cls.def("add_signals",
        [](daq::IMultiReaderBuilder *object, std::variant<daq::IList*, py::list, daq::IEvalValue*>& signals)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            objectPtr.addSignals(getVariantValue<daq::IList*>(signals));
        },
        py::arg("signals"),
        "Adds signals that will be read by the multi reader");
    cls.def("add_input_port",
        [](daq::IMultiReaderBuilder *object, daq::IInputPort* port)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            objectPtr.addInputPort(port);
        },
        py::arg("port"),
        "Adds a port that will be read from by the multi reader");
    cls.def("add_input_ports",
        [](daq::IMultiReaderBuilder *object, std::variant<daq::IList*, py::list, daq::IEvalValue*>& ports)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            objectPtr.addInputPorts(getVariantValue<daq::IList*>(ports));
        },
        py::arg("ports"),
        "Adds ports that will be read from by the multi reader");
    cls.def_property_readonly("source_components",
        [](daq::IMultiReaderBuilder *object)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            return objectPtr.getSourceComponents().detach();
        },
        py::return_value_policy::take_ownership,
        "Gets the list of read components (signals or ports)");
    cls.def_property("value_read_type",
        [](daq::IMultiReaderBuilder *object)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            return objectPtr.getValueReadType();
        },
        [](daq::IMultiReaderBuilder *object, daq::SampleType type)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            objectPtr.setValueReadType(type);
        },
        "Gets the value signal read type / Sets the value signal read type");
    cls.def_property("domain_read_type",
        [](daq::IMultiReaderBuilder *object)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            return objectPtr.getDomainReadType();
        },
        [](daq::IMultiReaderBuilder *object, daq::SampleType type)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            objectPtr.setDomainReadType(type);
        },
        "Gets the domain signal read type / Sets the domain signal read type");
    cls.def_property("read_mode",
        [](daq::IMultiReaderBuilder *object)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            return objectPtr.getReadMode();
        },
        [](daq::IMultiReaderBuilder *object, daq::ReadMode mode)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            objectPtr.setReadMode(mode);
        },
        "Gets the read mode (Unscaled, Scaled, RawValue) / Sets the read mode (Unscaled, Scaled, RawValue)");
    cls.def_property("read_timeout_type",
        [](daq::IMultiReaderBuilder *object)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            return objectPtr.getReadTimeoutType();
        },
        [](daq::IMultiReaderBuilder *object, daq::ReadTimeoutType type)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            objectPtr.setReadTimeoutType(type);
        },
        "Gets the read timeout mode / Sets the read timeout mode");
    cls.def_property("required_common_sample_rate",
        [](daq::IMultiReaderBuilder *object)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            return objectPtr.getRequiredCommonSampleRate();
        },
        [](daq::IMultiReaderBuilder *object, daq::Int sampleRate)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            objectPtr.setRequiredCommonSampleRate(sampleRate);
        },
        "Gets the required common sample rate / Sets the required common sample rate");
    cls.def_property("start_on_full_unit_of_domain",
        [](daq::IMultiReaderBuilder *object)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            return objectPtr.getStartOnFullUnitOfDomain();
        },
        [](daq::IMultiReaderBuilder *object, const bool enabled)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            objectPtr.setStartOnFullUnitOfDomain(enabled);
        },
        "Gets the start on full unit of domain / Sets the start on full unit of domain");
    cls.def_property("min_read_count",
        [](daq::IMultiReaderBuilder *object)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            return objectPtr.getMinReadCount();
        },
        [](daq::IMultiReaderBuilder *object, const size_t minReadCount)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            objectPtr.setMinReadCount(minReadCount);
        },
        "Gets the minimal number of samples to read. / Sets the minimal number of samples to read.");
    cls.def_property("tick_offset_tolerance",
        [](daq::IMultiReaderBuilder *object)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            return objectPtr.getTickOffsetTolerance().detach();
        },
        [](daq::IMultiReaderBuilder *object, std::variant<daq::IRatio*, std::pair<int64_t, int64_t>>& offsetTolerance)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            objectPtr.setTickOffsetTolerance(getVariantValue<daq::IRatio*>(offsetTolerance));
        },
        py::return_value_policy::take_ownership,
        "Get maximum distance between signals in fractions of domain unit / Set maximum distance between signals in fractions of domain unit");
    cls.def_property("allow_different_sampling_rates",
        [](daq::IMultiReaderBuilder *object)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            return objectPtr.getAllowDifferentSamplingRates();
        },
        [](daq::IMultiReaderBuilder *object, const bool allowDifferentRates)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            objectPtr.setAllowDifferentSamplingRates(allowDifferentRates);
        },
        "Gets the \"AllowDifferentSamplingRates\" multi reader parameter. / Sets the \"AllowDifferentSamplingRates\" multi reader parameter.");
    cls.def_property("input_port_notification_method",
        [](daq::IMultiReaderBuilder *object)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            return objectPtr.getInputPortNotificationMethod();
        },
        [](daq::IMultiReaderBuilder *object, daq::PacketReadyNotification notificationMethod)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            objectPtr.setInputPortNotificationMethod(notificationMethod);
        },
        "Gets the notification method of ports created/owned by the multi reader. The default notification method is SameThread. / Sets the notification method of ports created/owned by the multi reader. The default notification method is Unspecified.");
    cls.def_property("input_port_notification_methods",
        [](daq::IMultiReaderBuilder *object)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            return objectPtr.getInputPortNotificationMethods().detach();
        },
        [](daq::IMultiReaderBuilder *object, std::variant<daq::IList*, py::list, daq::IEvalValue*>& notificationMethods)
        {
            py::gil_scoped_release release;
            const auto objectPtr = daq::MultiReaderBuilderPtr::Borrow(object);
            objectPtr.setInputPortNotificationMethods(getVariantValue<daq::IList*>(notificationMethods));
        },
        py::return_value_policy::take_ownership,
        "Gets the notification methods of ports created/owned by the multi reader. The default notification method is Unspecified. / Sets the notification methods of ports created/owned by the multi reader. The default notification method is Unspecified.");
}
