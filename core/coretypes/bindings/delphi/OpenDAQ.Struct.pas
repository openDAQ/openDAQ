//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
//     RTGen (DelphiGenerator v4.0.1) on 03.10.2023 11:52:51.
// </auto-generated>
//------------------------------------------------------------------------------
unit OpenDAQ.Struct;

interface
uses
  OpenDAQ.CoreTypes,
  OpenDAQ.ObjectPtr,
  OpenDAQ.ProxyValue,
  OpenDAQ.TString,
  OpenDAQ.Dict,
  OpenDAQ.TypeManager,
  OpenDAQ.StructType,
  OpenDAQ.List;

type
  {$MINENUMSIZE 4}

  IStruct = interface(IBaseObject)
  ['{2B9F7790-512A-591E-86AC-886E9DE68A52}']
    function GetStructType(out AType: IStructType): ErrCode; stdcall;
    function GetFieldNames(out Names: IListObject): ErrCode; stdcall;
    function GetFieldValues(out Values: IListObject): ErrCode; stdcall;
    function Get(Name: IString; out Field: IBaseObject): ErrCode; stdcall;
    function GetAsDictionary(out Dictionary: IDictObject): ErrCode; stdcall;
    function HasField(Name: IString; out Contains: Boolean): ErrCode; stdcall;
  end;

  IStructPtr = interface(IObjectPtr<IStruct>)
  ['{f56a226f-8a44-57fd-aa3c-65a5ed05d5c4}']
    /// <summary>Gets the Struct's type.</summary>
    /// <returns>The Struct type<returns>
    function GetStructType(): IStructTypePtr;

    /// <summary>Gets a list of all Struct field names.</summary>
    /// <returns>The list of field names.<returns>
    /// <remarks>
    /// The list of names will be of equal length to the list of values. Additionally, the name of a field at any given
    /// index corresponds to the value stored in the list of values.
    /// </remarks>
    function GetFieldNames(): IListPtr<IString>;

    /// <summary>Gets a list of all Struct field values.</summary>
    /// <returns>The list of field values.<returns>
    /// <remarks>
    /// The list of names will be of equal length to the list of values. Additionally, the name of a field at any given
    /// index corresponds to the value stored in the list of values.
    /// </remarks>
    function GetFieldValues(): IListPtr<IBaseObject>;

    /// <summary>Gets the value of a field with the given name.</summary>
    /// <param name="name">The name of the queried field.</param>
    /// <returns>The value of the field.<returns>
    function Get(Name: IString): TProxyValue; overload;

    /// <summary>Gets the value of a field with the given name.</summary>
    /// <param name="name">The name of the queried field.</param>
    /// <returns>The value of the field.<returns>
    function Get(Name: IStringPtr): TProxyValue; overload;

    /// <summary>Gets the value of a field with the given name.</summary>
    /// <param name="name">The name of the queried field.</param>
    /// <returns>The value of the field.<returns>
    function Get(Name: string): TProxyValue; overload;


    /// <summary>Gets the field names and values of the Struct as a Dictionary.</summary>
    /// <returns>The Dictionary object with field names as keys, and field values as its values.<returns>
    function GetAsDictionary(): IDictionaryPtr<IString, IBaseObject>;

    /// <summary>Checks whether a field with the given name exists in the Struct</summary>
    /// <param name="name">The name of the checked field.</param>
    /// <returns>True if the a field with `name` exists in the Struct; false otherwise.<returns>
    function HasField(Name: IString): Boolean; overload;

    /// <summary>Checks whether a field with the given name exists in the Struct</summary>
    /// <param name="name">The name of the checked field.</param>
    /// <returns>True if the a field with `name` exists in the Struct; false otherwise.<returns>
    function HasField(Name: IStringPtr): Boolean; overload;

    /// <summary>Checks whether a field with the given name exists in the Struct</summary>
    /// <param name="name">The name of the checked field.</param>
    /// <returns>True if the a field with `name` exists in the Struct; false otherwise.<returns>
    function HasField(Name: string): Boolean; overload;
  end;

  TStructPtr = class(TObjectPtr<IStruct>, IStructPtr, IStruct)
  public
    constructor Create(Obj: IBaseObject); overload; override;
    constructor Create(Obj: IStruct); overload;

    // Factory constructors
    constructor Create(Name: IString; Fields: IDictObject; TypeManager: ITypeManager) overload;
    constructor Create(Name: string; Fields: IDictObject; TypeManager: ITypeManager) overload;

    /// <summary>Gets the Struct's type.</summary>
    /// <returns>The Struct type<returns>
    function GetStructType(): IStructTypePtr;

    /// <summary>Gets a list of all Struct field names.</summary>
    /// <returns>The list of field names.<returns>
    /// <remarks>
    /// The list of names will be of equal length to the list of values. Additionally, the name of a field at any given
    /// index corresponds to the value stored in the list of values.
    /// </remarks>
    function GetFieldNames(): IListPtr<IString>;

    /// <summary>Gets a list of all Struct field values.</summary>
    /// <returns>The list of field values.<returns>
    /// <remarks>
    /// The list of names will be of equal length to the list of values. Additionally, the name of a field at any given
    /// index corresponds to the value stored in the list of values.
    /// </remarks>
    function GetFieldValues(): IListPtr<IBaseObject>;

    /// <summary>Gets the value of a field with the given name.</summary>
    /// <param name="name">The name of the queried field.</param>
    /// <returns>The value of the field.<returns>
    function Get(Name: IString): TProxyValue; overload;

    /// <summary>Gets the value of a field with the given name.</summary>
    /// <param name="name">The name of the queried field.</param>
    /// <returns>The value of the field.<returns>
    function Get(Name: IStringPtr): TProxyValue; overload;

    /// <summary>Gets the value of a field with the given name.</summary>
    /// <param name="name">The name of the queried field.</param>
    /// <returns>The value of the field.<returns>
    function Get(Name: string): TProxyValue; overload;


    /// <summary>Gets the field names and values of the Struct as a Dictionary.</summary>
    /// <returns>The Dictionary object with field names as keys, and field values as its values.<returns>
    function GetAsDictionary(): IDictionaryPtr<IString, IBaseObject>;

    /// <summary>Checks whether a field with the given name exists in the Struct</summary>
    /// <param name="name">The name of the checked field.</param>
    /// <returns>True if the a field with `name` exists in the Struct; false otherwise.<returns>
    function HasField(Name: IString): Boolean; overload;

    /// <summary>Checks whether a field with the given name exists in the Struct</summary>
    /// <param name="name">The name of the checked field.</param>
    /// <returns>True if the a field with `name` exists in the Struct; false otherwise.<returns>
    function HasField(Name: IStringPtr): Boolean; overload;

    /// <summary>Checks whether a field with the given name exists in the Struct</summary>
    /// <param name="name">The name of the checked field.</param>
    /// <returns>True if the a field with `name` exists in the Struct; false otherwise.<returns>
    function HasField(Name: string): Boolean; overload;
  private
    function IStruct.GetStructType = Interface_GetStructType;
    function IStruct.GetFieldNames = Interface_GetFieldNames;
    function IStruct.GetFieldValues = Interface_GetFieldValues;
    function IStruct.Get = Interface_Get;
    function IStruct.GetAsDictionary = Interface_GetAsDictionary;
    function IStruct.HasField = Interface_HasField;

    function Interface_GetStructType(out AType: IStructType): ErrCode; stdcall;
    function Interface_GetFieldNames(out Names: IListObject): ErrCode; stdcall;
    function Interface_GetFieldValues(out Values: IListObject): ErrCode; stdcall;
    function Interface_Get(Name: IString; out Field: IBaseObject): ErrCode; stdcall;
    function Interface_GetAsDictionary(out Dictionary: IDictObject): ErrCode; stdcall;
    function Interface_HasField(Name: IString; out Contains: Boolean): ErrCode; stdcall;
  end;

  function CreateStruct(out Obj: IStruct; Name: IString; Fields: IDictObject; TypeManager: ITypeManager): ErrCode; cdecl;

implementation
uses
  OpenDAQ.CoreTypes.Errors,
  OpenDAQ.Exceptions,
  OpenDAQ.CoreTypes.Config,
  OpenDAQ.SmartPtrRegistry;

  function CreateStruct(out Obj: IStruct; Name: IString; Fields: IDictObject; TypeManager: ITypeManager): ErrCode; external DSCoreTypesDLL name 'createStruct';

constructor TStructPtr.Create(Obj: IStruct);
begin
  inherited Create(Obj);
end;

constructor TStructPtr.Create(Obj: IBaseObject);
begin
  inherited Create(Obj);
end;

constructor TStructPtr.Create(Name: IString; Fields: IDictObject; TypeManager: ITypeManager);
var
  RawInterface: IStruct;
  Err: ErrCode;
begin
  Err := OpenDAQ.Struct.CreateStruct(RawInterface, Name, Fields, TypeManager);
  CheckRtErrorInfo(Err);

  inherited Create(RawInterface);
end;

constructor TStructPtr.Create(Name: string; Fields: IDictObject; TypeManager: ITypeManager);
var
  RawInterface: IStruct;
  Err: ErrCode;
begin
  Err := OpenDAQ.Struct.CreateStruct(RawInterface, CreateStringFromDelphiString(Name), Fields, TypeManager);
  CheckRtErrorInfo(Err);

  inherited Create(RawInterface);
end;

function TStructPtr.GetStructType(): IStructTypePtr;
var
  Err: ErrCode;
  AType: IStructType;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  Err := FObject.GetStructType(AType);
  CheckRtErrorInfo(Err);

  Result := TStructTypePtr.Create(AType);
end;

function TStructPtr.GetFieldNames(): IListPtr<IString>;
var
  Err: ErrCode;
  Names: IListObject;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  Err := FObject.GetFieldNames(Names);
  CheckRtErrorInfo(Err);

  Result := TListPtr<IString>.Create(Names);
end;

function TStructPtr.GetFieldValues(): IListPtr<IBaseObject>;
var
  Err: ErrCode;
  Values: IListObject;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  Err := FObject.GetFieldValues(Values);
  CheckRtErrorInfo(Err);

  Result := TListPtr<IBaseObject>.Create(Values);
end;

function TStructPtr.Get(Name: IString): TProxyValue;
var
  Err: ErrCode;
  Field: IBaseObject;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  Err := FObject.Get(Name, Field);
  CheckRtErrorInfo(Err);

  Result := TProxyValue.Create(Field);
end;

function TStructPtr.Get(Name: IStringPtr): TProxyValue;
var
  Err: ErrCode;
  Field: IBaseObject;
  NameIntf: IString;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  if Assigned(Name) then
    NameIntf := Name.GetInterface()
  else
    NameIntf := nil;

  Err := FObject.Get(NameIntf, Field);
  CheckRtErrorInfo(Err);

  Result := TProxyValue.Create(Field);
end;

function TStructPtr.Get(Name: string): TProxyValue;
var
  Err: ErrCode;
  Field: IBaseObject;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  Err := FObject.Get(CreateStringFromDelphiString(Name), Field);
  CheckRtErrorInfo(Err);

  Result := TProxyValue.Create(Field);
end;

function TStructPtr.GetAsDictionary(): IDictionaryPtr<IString, IBaseObject>;
var
  Err: ErrCode;
  Dictionary: IDictObject;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  Err := FObject.GetAsDictionary(Dictionary);
  CheckRtErrorInfo(Err);

  Result := TDictionaryPtr<IString, IBaseObject>.Create(Dictionary);
end;

function TStructPtr.HasField(Name: IString): Boolean;
var
  Err: ErrCode;
  Contains: Boolean;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  Err := FObject.HasField(Name, Contains);
  CheckRtErrorInfo(Err);

  Result := Contains;
end;

function TStructPtr.HasField(Name: IStringPtr): Boolean;
var
  Err: ErrCode;
  Contains: Boolean;
  NameIntf: IString;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  if Assigned(Name) then
    NameIntf := Name.GetInterface()
  else
    NameIntf := nil;

  Err := FObject.HasField(NameIntf, Contains);
  CheckRtErrorInfo(Err);

  Result := Contains;
end;

function TStructPtr.HasField(Name: string): Boolean;
var
  Err: ErrCode;
  Contains: Boolean;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  Err := FObject.HasField(CreateStringFromDelphiString(Name), Contains);
  CheckRtErrorInfo(Err);

  Result := Contains;
end;

function TStructPtr.Interface_GetStructType(out AType: IStructType): ErrCode; stdcall;
begin
  Result := FObject.GetStructType(AType);
end;

function TStructPtr.Interface_GetFieldNames(out Names: IListObject): ErrCode; stdcall;
begin
  Result := FObject.GetFieldNames(Names);
end;

function TStructPtr.Interface_GetFieldValues(out Values: IListObject): ErrCode; stdcall;
begin
  Result := FObject.GetFieldValues(Values);
end;

function TStructPtr.Interface_Get(Name: IString; out Field: IBaseObject): ErrCode; stdcall;
begin
  Result := FObject.Get(Name, Field);
end;

function TStructPtr.Interface_GetAsDictionary(out Dictionary: IDictObject): ErrCode; stdcall;
begin
  Result := FObject.GetAsDictionary(Dictionary);
end;

function TStructPtr.Interface_HasField(Name: IString; out Contains: Boolean): ErrCode; stdcall;
begin
  Result := FObject.HasField(Name, Contains);
end;

initialization
  TSmartPtrRegistry.RegisterPtr(IStruct, IStructPtr, TStructPtr);

finalization
  TSmartPtrRegistry.UnregisterPtr(IStruct);

end.
