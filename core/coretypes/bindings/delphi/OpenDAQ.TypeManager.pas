//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
//     RTGen (DelphiGenerator v4.0.1) on 03.10.2023 11:18:20.
// </auto-generated>
//------------------------------------------------------------------------------
unit OpenDAQ.TypeManager;

interface
uses
  OpenDAQ.CoreTypes,
  OpenDAQ.ObjectPtr,
  OpenDAQ.ProxyValue,
  OpenDAQ.TType,
  OpenDAQ.TString,
  OpenDAQ.List;

type
  {$MINENUMSIZE 4}

  ITypeManager = interface(IBaseObject)
  ['{EBD840C6-7E32-51F4-B063-63D0B09F4240}']
    function AddType(AType: IType): ErrCode; stdcall;
    function RemoveType(TypeName: IString): ErrCode; stdcall;
    function GetType(TypeName: IString; out AType: IType): ErrCode; stdcall;
    function GetTypes(out Types: IListObject): ErrCode; stdcall;
    function HasType(TypeName: IString; out HasType: Boolean): ErrCode; stdcall;
  end;

  ITypeManagerPtr = interface(IObjectPtr<ITypeManager>)
  ['{5eff4246-70d2-55dd-aec6-e66788a1f273}']
    /// <summary>Adds a type to the manager.</summary>
    /// <param name="type">The Type to be added.</param>
    /// <throws>AlreadyExistsException if a type with the same name is already added.<throws>
    /// <throws>InvalidParameterException if either the type name is an empty string.<throws>
    /// <remarks>
    /// The type name must be unique and. If a Property object class specifies a parent class,
    /// then the parent class must be added before it.
    /// </remarks>
    procedure AddType(AType: IType); overload;

    /// <summary>Adds a type to the manager.</summary>
    /// <param name="type">The Type to be added.</param>
    /// <throws>AlreadyExistsException if a type with the same name is already added.<throws>
    /// <throws>InvalidParameterException if either the type name is an empty string.<throws>
    /// <remarks>
    /// The type name must be unique and. If a Property object class specifies a parent class,
    /// then the parent class must be added before it.
    /// </remarks>
    procedure AddType(AType: ITypePtr); overload;


    /// <summary>Removes the type from the manager.</summary>
    /// <param name="typeName">The type's name.</param>
    /// <throws>NotFoundException if the class is not registered.<throws>
    /// <remarks>
    /// The removed class must not be a parent of another added class. If it is, those classes must be removed
    /// before it.
    /// </remarks>
    procedure RemoveType(TypeName: IString); overload;

    /// <summary>Removes the type from the manager.</summary>
    /// <param name="typeName">The type's name.</param>
    /// <throws>NotFoundException if the class is not registered.<throws>
    /// <remarks>
    /// The removed class must not be a parent of another added class. If it is, those classes must be removed
    /// before it.
    /// </remarks>
    procedure RemoveType(TypeName: IStringPtr); overload;

    /// <summary>Removes the type from the manager.</summary>
    /// <param name="typeName">The type's name.</param>
    /// <throws>NotFoundException if the class is not registered.<throws>
    /// <remarks>
    /// The removed class must not be a parent of another added class. If it is, those classes must be removed
    /// before it.
    /// </remarks>
    procedure RemoveType(TypeName: string); overload;


    /// <summary>Gets an added Type by name.</summary>
    /// <param name="typeName">The Type's name.</param>
    /// <returns>The Type with name equal to `name`.<returns>
    /// <throws>NotFoundException if a Type with the specified name is not added.<throws>
    function GetType(TypeName: IString): ITypePtr; overload;

    /// <summary>Gets an added Type by name.</summary>
    /// <param name="typeName">The Type's name.</param>
    /// <returns>The Type with name equal to `name`.<returns>
    /// <throws>NotFoundException if a Type with the specified name is not added.<throws>
    function GetType(TypeName: IStringPtr): ITypePtr; overload;

    /// <summary>Gets an added Type by name.</summary>
    /// <param name="typeName">The Type's name.</param>
    /// <returns>The Type with name equal to `name`.<returns>
    /// <throws>NotFoundException if a Type with the specified name is not added.<throws>
    function GetType(TypeName: string): ITypePtr; overload;


    /// <summary>Gets a list of all added Types.</summary>
    /// <returns>The list of all added Types.<returns>
    function GetTypes(): IListPtr<IType>;

    /// <summary>Checks if a type with the specified name is already added.</summary>
    /// <param name="typeName">The name of the checked type.</param>
    /// <returns>True if the type is aready added to the manager; False otherwise.<returns>
    function HasType(TypeName: IString): Boolean; overload;

    /// <summary>Checks if a type with the specified name is already added.</summary>
    /// <param name="typeName">The name of the checked type.</param>
    /// <returns>True if the type is aready added to the manager; False otherwise.<returns>
    function HasType(TypeName: IStringPtr): Boolean; overload;

    /// <summary>Checks if a type with the specified name is already added.</summary>
    /// <param name="typeName">The name of the checked type.</param>
    /// <returns>True if the type is aready added to the manager; False otherwise.<returns>
    function HasType(TypeName: string): Boolean; overload;
  end;

  TTypeManagerPtr = class(TObjectPtr<ITypeManager>, ITypeManagerPtr, ITypeManager)
  public
    constructor Create(Obj: IBaseObject); overload; override;
    constructor Create(Obj: ITypeManager); overload;

    // Factory constructors
    constructor Create() overload; override;

    /// <summary>Adds a type to the manager.</summary>
    /// <param name="type">The Type to be added.</param>
    /// <throws>AlreadyExistsException if a type with the same name is already added.<throws>
    /// <throws>InvalidParameterException if either the type name is an empty string.<throws>
    /// <remarks>
    /// The type name must be unique and. If a Property object class specifies a parent class,
    /// then the parent class must be added before it.
    /// </remarks>
    procedure AddType(AType: IType); overload;

    /// <summary>Adds a type to the manager.</summary>
    /// <param name="type">The Type to be added.</param>
    /// <throws>AlreadyExistsException if a type with the same name is already added.<throws>
    /// <throws>InvalidParameterException if either the type name is an empty string.<throws>
    /// <remarks>
    /// The type name must be unique and. If a Property object class specifies a parent class,
    /// then the parent class must be added before it.
    /// </remarks>
    procedure AddType(AType: ITypePtr); overload;


    /// <summary>Removes the type from the manager.</summary>
    /// <param name="typeName">The type's name.</param>
    /// <throws>NotFoundException if the class is not registered.<throws>
    /// <remarks>
    /// The removed class must not be a parent of another added class. If it is, those classes must be removed
    /// before it.
    /// </remarks>
    procedure RemoveType(TypeName: IString); overload;

    /// <summary>Removes the type from the manager.</summary>
    /// <param name="typeName">The type's name.</param>
    /// <throws>NotFoundException if the class is not registered.<throws>
    /// <remarks>
    /// The removed class must not be a parent of another added class. If it is, those classes must be removed
    /// before it.
    /// </remarks>
    procedure RemoveType(TypeName: IStringPtr); overload;

    /// <summary>Removes the type from the manager.</summary>
    /// <param name="typeName">The type's name.</param>
    /// <throws>NotFoundException if the class is not registered.<throws>
    /// <remarks>
    /// The removed class must not be a parent of another added class. If it is, those classes must be removed
    /// before it.
    /// </remarks>
    procedure RemoveType(TypeName: string); overload;


    /// <summary>Gets an added Type by name.</summary>
    /// <param name="typeName">The Type's name.</param>
    /// <returns>The Type with name equal to `name`.<returns>
    /// <throws>NotFoundException if a Type with the specified name is not added.<throws>
    function GetType(TypeName: IString): ITypePtr; overload;

    /// <summary>Gets an added Type by name.</summary>
    /// <param name="typeName">The Type's name.</param>
    /// <returns>The Type with name equal to `name`.<returns>
    /// <throws>NotFoundException if a Type with the specified name is not added.<throws>
    function GetType(TypeName: IStringPtr): ITypePtr; overload;

    /// <summary>Gets an added Type by name.</summary>
    /// <param name="typeName">The Type's name.</param>
    /// <returns>The Type with name equal to `name`.<returns>
    /// <throws>NotFoundException if a Type with the specified name is not added.<throws>
    function GetType(TypeName: string): ITypePtr; overload;


    /// <summary>Gets a list of all added Types.</summary>
    /// <returns>The list of all added Types.<returns>
    function GetTypes(): IListPtr<IType>;

    /// <summary>Checks if a type with the specified name is already added.</summary>
    /// <param name="typeName">The name of the checked type.</param>
    /// <returns>True if the type is aready added to the manager; False otherwise.<returns>
    function HasType(TypeName: IString): Boolean; overload;

    /// <summary>Checks if a type with the specified name is already added.</summary>
    /// <param name="typeName">The name of the checked type.</param>
    /// <returns>True if the type is aready added to the manager; False otherwise.<returns>
    function HasType(TypeName: IStringPtr): Boolean; overload;

    /// <summary>Checks if a type with the specified name is already added.</summary>
    /// <param name="typeName">The name of the checked type.</param>
    /// <returns>True if the type is aready added to the manager; False otherwise.<returns>
    function HasType(TypeName: string): Boolean; overload;
  private
    function ITypeManager.AddType = Interface_AddType;
    function ITypeManager.RemoveType = Interface_RemoveType;
    function ITypeManager.GetType = Interface_GetType;
    function ITypeManager.GetTypes = Interface_GetTypes;
    function ITypeManager.HasType = Interface_HasType;

    function Interface_AddType(AType: IType): ErrCode; stdcall;
    function Interface_RemoveType(TypeName: IString): ErrCode; stdcall;
    function Interface_GetType(TypeName: IString; out AType: IType): ErrCode; stdcall;
    function Interface_GetTypes(out Types: IListObject): ErrCode; stdcall;
    function Interface_HasType(TypeName: IString; out HasType: Boolean): ErrCode; stdcall;
  end;

  function CreateTypeManager(out Obj: ITypeManager): ErrCode; cdecl;

implementation
uses
  OpenDAQ.CoreTypes.Errors,
  OpenDAQ.Exceptions,
  OpenDAQ.CoreTypes.Config,
  OpenDAQ.SmartPtrRegistry;

  function CreateTypeManager(out Obj: ITypeManager): ErrCode; external DSCoreTypesDLL name 'createTypeManager';

constructor TTypeManagerPtr.Create(Obj: ITypeManager);
begin
  inherited Create(Obj);
end;

constructor TTypeManagerPtr.Create(Obj: IBaseObject);
begin
  inherited Create(Obj);
end;

constructor TTypeManagerPtr.Create();
var
  RawInterface: ITypeManager;
  Err: ErrCode;
begin
  Err := OpenDAQ.TypeManager.CreateTypeManager(RawInterface);
  CheckRtErrorInfo(Err);

  inherited Create(RawInterface);
end;

procedure TTypeManagerPtr.AddType(AType: IType);
var
  Err: ErrCode;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  Err := FObject.AddType(AType);
  CheckRtErrorInfo(Err);
end;

procedure TTypeManagerPtr.AddType(AType: ITypePtr);
var
  Err: ErrCode;
  TypeIntf: IType;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  if Assigned(AType) then
    TypeIntf := AType.GetInterface()
  else
    TypeIntf := nil;

  Err := FObject.AddType(TypeIntf);
  CheckRtErrorInfo(Err);
end;

procedure TTypeManagerPtr.RemoveType(TypeName: IString);
var
  Err: ErrCode;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  Err := FObject.RemoveType(TypeName);
  CheckRtErrorInfo(Err);
end;

procedure TTypeManagerPtr.RemoveType(TypeName: IStringPtr);
var
  Err: ErrCode;
  TypeNameIntf: IString;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  if Assigned(TypeName) then
    TypeNameIntf := TypeName.GetInterface()
  else
    TypeNameIntf := nil;

  Err := FObject.RemoveType(TypeNameIntf);
  CheckRtErrorInfo(Err);
end;

procedure TTypeManagerPtr.RemoveType(TypeName: string);
var
  Err: ErrCode;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  Err := FObject.RemoveType(CreateStringFromDelphiString(TypeName));
  CheckRtErrorInfo(Err);
end;

function TTypeManagerPtr.GetType(TypeName: IString): ITypePtr;
var
  Err: ErrCode;
  AType: IType;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  Err := FObject.GetType(TypeName, AType);
  CheckRtErrorInfo(Err);

  Result := TTypePtr.Create(AType);
end;

function TTypeManagerPtr.GetType(TypeName: IStringPtr): ITypePtr;
var
  Err: ErrCode;
  AType: IType;
  TypeNameIntf: IString;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  if Assigned(TypeName) then
    TypeNameIntf := TypeName.GetInterface()
  else
    TypeNameIntf := nil;

  Err := FObject.GetType(TypeNameIntf, AType);
  CheckRtErrorInfo(Err);

  Result := TTypePtr.Create(AType);
end;

function TTypeManagerPtr.GetType(TypeName: string): ITypePtr;
var
  Err: ErrCode;
  AType: IType;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  Err := FObject.GetType(CreateStringFromDelphiString(TypeName), AType);
  CheckRtErrorInfo(Err);

  Result := TTypePtr.Create(AType);
end;

function TTypeManagerPtr.GetTypes(): IListPtr<IType>;
var
  Err: ErrCode;
  Types: IListObject;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  Err := FObject.GetTypes(Types);
  CheckRtErrorInfo(Err);

  Result := TListPtr<IType>.Create(Types);
end;

function TTypeManagerPtr.HasType(TypeName: IString): Boolean;
var
  Err: ErrCode;
  HasType: Boolean;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  Err := FObject.HasType(TypeName, HasType);
  CheckRtErrorInfo(Err);

  Result := HasType;
end;

function TTypeManagerPtr.HasType(TypeName: IStringPtr): Boolean;
var
  Err: ErrCode;
  HasType: Boolean;
  TypeNameIntf: IString;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  if Assigned(TypeName) then
    TypeNameIntf := TypeName.GetInterface()
  else
    TypeNameIntf := nil;

  Err := FObject.HasType(TypeNameIntf, HasType);
  CheckRtErrorInfo(Err);

  Result := HasType;
end;

function TTypeManagerPtr.HasType(TypeName: string): Boolean;
var
  Err: ErrCode;
  HasType: Boolean;
begin
  if not Assigned(FObject) then
    raise ERTInvalidParameterException.Create('Interface object is nil.');

  Err := FObject.HasType(CreateStringFromDelphiString(TypeName), HasType);
  CheckRtErrorInfo(Err);

  Result := HasType;
end;

function TTypeManagerPtr.Interface_AddType(AType: IType): ErrCode; stdcall;
begin
  Result := FObject.AddType(AType);
end;

function TTypeManagerPtr.Interface_RemoveType(TypeName: IString): ErrCode; stdcall;
begin
  Result := FObject.RemoveType(TypeName);
end;

function TTypeManagerPtr.Interface_GetType(TypeName: IString; out AType: IType): ErrCode; stdcall;
begin
  Result := FObject.GetType(TypeName, AType);
end;

function TTypeManagerPtr.Interface_GetTypes(out Types: IListObject): ErrCode; stdcall;
begin
  Result := FObject.GetTypes(Types);
end;

function TTypeManagerPtr.Interface_HasType(TypeName: IString; out HasType: Boolean): ErrCode; stdcall;
begin
  Result := FObject.HasType(TypeName, HasType);
end;

initialization
  TSmartPtrRegistry.RegisterPtr(ITypeManager, ITypeManagerPtr, TTypeManagerPtr);

finalization
  TSmartPtrRegistry.UnregisterPtr(ITypeManager);

end.
