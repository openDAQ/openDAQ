= MultiReader specification

== Overview

The MultiReader is used to read several signals simultaneously, synchronizing them in time.

== Signal Requirements

- **Domain**: The domain signal must represent time in seconds. The domain unit must have the symbol "s" and the quantity "time".
- **Rule**: A linear rule is the only type acceptable for the MultiReader.
- **Sampling Rates (SRs)**: All sampling rates must be compatible and measured as an integer number of samples per second.
- **Reference Domain Info**: Signals sharing a domain must have matching reference domain identifiers. 
  Each domain group must have at least one known time source, and only one time source is allowed across all groups.

== Setup (Builder) Options

- **Min read count**: Set the minimal amount of samples that could be read from MultiReader.
- **Required common sample rate**: Behaves as if there were one more signal with this sample rate.
- **Start on full unit of domain**: Align offset of each signal to common start on full units of domain.
- **Ports vs. Signals**: The MultiReader can be constructed using input ports or signals, but not a mixture of both.
  - *Ports*: Allow detection of gaps between packets.
  - *Signals*: Do not support gap detection.

== Use Cases

=== Basic

Basic use case is when the user reads signals with the same sample rate.

Example of how to create a MultiReader from input ports (assuming that the input ports were created beforehand):

[tabs]
====
Cpp::
+
[source,cpp]
----
auto multiReaderBuilder = daq::MultiReaderBuilder();
multiReaderBuilder.setDomainReadType(daq::SampleType::Int64);
multiReaderBuilder.setValueReadType(daq::SampleType::Int64);
for (const auto& inputPort : inputPorts)
    multiReaderBuilder.addInputPort(inputPort);
auto multiReader = multiReaderBuilder.build();
----
====

The first read of the MultiReader always returns a sample count of 0 because the MultiReader provides signal descriptors during the initial read. 
These descriptors can be validated and either accepted or rejected. As a result, the MultiReader can be deactivated by calling `multiReader.setActive(false)`.

This action prevents the MultiReader from receiving data packets, while still allowing it to process descriptor change events, which could lead to its reactivation. 
While deactivated, the MultiReader will not accumulate data packets in its internal queues, ensuring it does not run out of memory.

After the user has initially read the data descriptors of the packets, it's time to read the data. The MultiReader returns data to the user in a "jagged array." 
The allocated memory for the jagged array is provided through a `void**` pointer in the `read()/readWithDomain()` call. In fact, the first indirection of this 
pointer points to a `void*`, which in turn points to an array of memory cells of the type used during the MultiReader creation.

In the example, the openDAQ type of the cells was `daq::SampleType::Int64`, which can be converted to a C++ type as `daq::SampleTypeToType<SampleType::Int64>::Type`. 
To use `daq::SampleType` with functions like `calloc()`, which need to know the cell size, you can use `daq::getSampleSize(daq::SampleType::Int64)`.

To determine how much space should be reserved for each signal in the jagged array, the user should calculate the dividers for each signal. In the basic case, 
when all sample rates are the same, the dividers will also be the same, and their usage can be omitted.

For example:

[tabs]
====
Cpp::
+
[source,cpp]
----
// read initial event packets
auto count = daq::SizeT{0};
auto status = multiReader.read(nullptr, &count);

// read data
auto samplesAvailable = multiReader.getAvailableCount();
std::vector<void*> domainBuffers(inputPorts.size(), nullptr);
std::vector<void*> dataBuffers(inputPorts.size(), nullptr);
for (auto i = 0; i < inputPorts.size(); ++i)
{
    domainBuffers[i] = std::calloc(samplesAvailable, daq::getSampleSize(daq::SampleType::Int64));
    dataBuffers[i] = std::calloc(samplesAvailable, daq::getSampleSize(daq::SampleType::Int64));
}
auto status = multiReader.readWithDomain(dataBuffers.data(), domainBuffers.data(), &count);
----
====

Note that in the example, the maximum number of samples that can be requested from the MultiReader is `kPacketSize`. This represents the 
maximum number of samples that can be obtained from the MultiReader. Be sure to adjust this size according to your needs when using this
example directly.

Below is an example of how to read and interpret data from the domain buffer. Notice that the domain data should be calculated relative 
to the common origin, which should be obtained from the MultiReader using the `getCommonOrigin()` call. The number of samples for each 
signal should be calculated from the `count` returned by the `read()/readWithDomain()` call and divided by the appropriate divider. 
Also, `count` cannot be less than the `minReadCount` parameter, if it was used during the MultiReader creation. If `minReadCount` was used, 
a special case of reading called "zero read count" could occur â€” when the requested `count` is aligned to zero or was zero initially. 
In this case, the minimum available number of samples across all signals will be skipped during reading if there is an event packet in 
one of the input ports' connection queues.

[tabs]
====
Cpp::
+
[source,cpp]
----
auto origin = daq::reader::parseEpoch(multiReader.getOrigin());
for (auto i = 0; i < inputPorts.size(); ++i)
{
  auto* domainBuffer = static_cast<typename daq::SampleTypeToType<daq::SampleType::Int64>::Type*>(domainBuffers[i]);
  auto signal = inputPorts[i].getSignal();
  auto domainSignal = signal.getDomainSignal();
  auto tickResolution = domainSignal.getDescriptor().getTickResolution();
  for (int s = 0; s < count; ++s)
  {
      auto sample = domainBuffer[s];
      auto timePoint = origin + (std::chrono::milliseconds(1s) * tickResolution.getNumerator() / tickResolution.getDenominator()) * sample;
      std::cout << fmt::format("({} - {})", daq::reader::timePointString(timePoint), dataBuffer[s]) << std::endl;
  }
}
----
====

To simplify the creation of an output signal from something that uses the MultiReader, the user can make use of the main descriptor, 
which is determined automatically and returned in the status through the `getMainDescriptor()` call, along with the offset returned 
by the `getOffset()` call. This offset corresponds to the offset of the signal whose descriptor is considered the main one. Other signals
may have distinct offsets if they have different origins.


Example usage:

[tabs]
====
Cpp::
+
[source,cpp]
----
auto mainDescriptorEventPacket = status.getMainDescriptor();
auto mainDomainDescriptor = daq::daq::DataDescriptorPtr();
if (mainDescriptorEventPacket.getEventId() == event_packet_id::DATA_DESCRIPTOR_CHANGED)
  mainDomainDescriptor = mainDescriptorEventPacket.getParameters()[event_packet_id::DATA_DESCRIPTOR_CHANGED];
auto outputSignal = daq::SignalWithDescriptor(context, mainDomainDescriptor);
auto dataPacket = daq::DataPacket(mainDomainDescriptor, kPacketSize, status.getOffset());
outputSignal.sendPacket(dataPacket);
----
====

=== Different sample rates

The case of different sample rates differs from the basic case in several ways:
- The main descriptor and offset from the MultiReader status are no longer usable, because signals could have different sample rates.
- The output sample count will be different for each signal and should be calculated using dividers.

The divider for a particular signal is calculated as `commonSampleRate / signalSampleRate`. To obtain the common sample rate from the
MultiReader, the user can call the `getCommonSampleRate()` method. However, note that this method will return a value only after 
the user reads the descriptors for the first time, if the required sample rate was not set before during creation. In other cases, it will be
available right from the MultiReader creation.

To obtain the signal's sample rate, the user can call `daq::reader::getSampleRate(domainDescriptor)` on the domain descriptor if the signal was 
returned in the status from the first `read()/readWithDomain()` call.

Then, the user can allocate memory according to the requested number of samples, with the element count equal to `count / divider`, where `count` is 
the requested number of samples. The user cannot read fewer samples than the least common multiple (LCM) of the dividers of all signals connected 
to the MultiReader.

[tabs]
====
Cpp::
+
[source,cpp]
----
auto count = daq::SizeT{0};
auto status = multiReader.read(nullptr, &count);
auto commonSampleRate = multiReader.getCommonSampleRate();
auto dividers = daq::Dict<daq::IString, daq::IInteger>();
if (status.getReadStatus() == daq::ReadStatus::Event)
{
    auto eventPackets = status.getEventPackets();
    for (const auto& [id, eventPacket]: eventPackets)
    {
        if (eventPacket.getEventId() == event_packet_id::DATA_DESCRIPTOR_CHANGED)
        {
            auto eventParams = eventPacket.getParameters();
            if (eventParams.hasKey(event_packet_param::DOMAIN_DATA_DESCRIPTOR))
            {
                auto newDomainDescriptor = eventParams.get(event_packet_param::DOMAIN_DATA_DESCRIPTOR);
                auto sampleRate = daq::reader::getSampleRate(newDomainDescriptor);
                dividers[id] = commonSampleRate / sampleRate;
            }
        }
    }
}
const auto kPacketSize = daq::SizeT{10};
std::vector<void*> domainBuffers(inputPorts.size(), nullptr);
std::vector<void*> dataBuffers(inputPorts.size(), nullptr);
for (auto i = 0; i < inputPorts.size(); ++i)
{
    auto localId = inputPorts[i].get(inputPort.getLocalId());
    auto divider = dividers.get(localId);
    domainBuffers[i] = std::calloc(kPacketSize / divider, daq::getSampleSize(daq::SampleType::Int64));
    dataBuffers[i] = std::calloc(kPacketSize / divider, daq::getSampleSize(daq::SampleType::Int64));
}
auto availableSamples = multiReader.getAvailableCount();
auto count = std::min(kPacketSize, availableSamples);
auto status = multiReader.readWithDomain(dataBuffers.data(), domainBuffers.data(), &count);
----
====

== Limitations

- **No Asynchronous Signals**: The MultiReader does not support asynchronous signals. Only a linear rule is accepted for domain signals.
- **Gap Packets**: Gap packets can only be detected when the reader is created from ports, not directly from signals.
- **Fixed Sample Rates**: Changing input sample rates invalidates the reader.
- **Additions Post-Creation**: Adding new signals or ports to the reader after creation is not supported.
- **Tick Alignment**: Tick alignment and offsets must adhere to strict rules for synchronization.

== Internal Behavior

=== Synchronization

==== Process
Synchronization happens during three MultiReader calls - `getAvailableCount()` and `read()/readWithDomain()`. But synchronization 
inside `getAvailableCount()` is not a complete procedure.

To synchronize two signals, the MultiReader initially needs to read their domain descriptors from the connection queue. 
This can be achieved by `read()/readWithDomain()` calls. Before this call, `getAvailableCount()` will return 0, and the result 
of `getCommonSampleRate()` will also be unavailable.

On the first `read()/readWithDomain()` call, the MultiReader will save the resolution for each signal, set the unsynchronized state, 
save the origin, and calculate the sample rate. If the previous sample rate was not undefined and does not equal the new one, 
the MultiReader transitions to an invalid state. The common sample rate will be calculated as the LCM of the sample rates of 
each individual signal. If a required sample rate was used during creation, it will be used as the common sample rate. 
From the common sample rate, the divider for each individual signal will be calculated. The divider should not be equal to zero, and 
the common sample rate should be divisible by the divider without remainder. If this is not the case, the MultiReader becomes invalid. 
Additionally, the LCM of all dividers is calculated for use in aligning the count of available and read samples in `getAvailableCount()` 
and `read()/readWithDomain()` calls and is used to align the sample count in the `skipSamples()` call.

In terms of synchronization, `getAvailableCount()` and `read()/readWithDomain()` differ in that the former does not remove event packets from 
the connection queue, and the internal synchronization call is not able to perform synchronization because some samples are required
to be available. However, their amount will stay at 0 if the first packet in the connection is an event packet.

After event packets are removed from the beginning of the input port queues, synchronization can happen. The earliest epoch and highest 
resolution among all signals are calculated (the system resolution, which runs openDAQ, is also considered as one of the resolutions and 
often becomes the highest one). Then, for each signal, the offset in maximum resolution ticks from the earliest epoch value is calculated, 
along with a multiplier, which represents the ratio of the signal resolution to the maximum resolution and is used to convert signal ticks from
the signal resolution to the common maximum resolution.

Next, the MultiReader reads the start domain value of each signal. This includes scaling and applying the reference domain offset (if it was used). 
The latest domain value among all signals becomes the common starting point from which reading should start. This starting point offset is also 
rounded up to either an interval, which is defined as the ratio of the LCM of the sample rate dividers to the common sample rate, or to full 
units of the domain if such an option was used during creation.

When the starting point is found, each signal skips samples up to this point. When the domain value of a signal becomes greater than or equal to 
this starting point, it is considered synchronized. When all signals are synchronized, the entire MultiReader state also becomes synchronized.


==== Triggers

Resynchronization is triggered by domain descriptor updates or changes in the active state via the `setActive()` call. 
Changes in resolution or origin transfer the signal to an unsynchronized state, while changes in sample rate transfer it to an invalid state.

Resynchronization includes all the steps described in the synchronization process.

==== Drop Conditions

Synchronization is dropped if inputs violate domain or sample rate rules.

== Limitations Summary

- **No Async Signals**: Only synchronized signals are supported.
- **Fixed Sampling Rates**: Dynamic changes are not permitted.
- **Domain Offsets**: Add reference domain offsets should have the same time source.

By adhering to these structured guidelines, the MultiReader ensures robust and synchronized handling of signal data with varying characteristics.

