= Multi Reader specification
:stem:
:toc: auto

== Overview

The Multi Reader is used to read several signals simultaneously, synchronizing them in time. This document outlines some features, use cases, setup requirements, as well as limitations of the Multi Reader. The article assumes previous knowledge of openDAQ reader usage and focuses on the intricacies of the Multi Reader instead of basic Reader concepts. The guide uses {cpp} examples to showcase how the multi reader behaves.

== Multi reader example

Simple example on how to use the Multi Reader to read data of signals of equal sampling rates:

[tabs]
====
Cpp::
+
[source,cpp]
----
using namespace daq;
using namespace std::chrono_literals;

int main()
{
    auto instance = Instance();
    auto refDevice = instance.addDevice("daqref://device0");
    auto signals = refDevice.getSignalsRecursive();

    // Create reader that converts values to `double` and time data to `int64`
    auto multiReaderBuilder = MultiReaderBuilder().setValueReadType(SampleType::Float64).setDomainReadType(SampleType::Int64);
    for (const auto& signal : signals)
        multiReaderBuilder.addSignal(signal);
    auto multiReader = multiReaderBuilder.build();

    // Allocate buffers for each signal
    auto signalsCount = signals.getCount();
    auto kBufferSize = SizeT{0};
    auto domainBuffers = std::vector<void*>(signalsCount, nullptr);
    auto dataBuffers = std::vector<void*>(signalsCount, nullptr);

    // read data every 50ms, up to a maximum of kBufferSize samples
    for (size_t readCount = 0; readCount < 20; readCount++)
    {
        auto dataAvailable = multiReader.getAvailableCount();
        auto count = std::min(kBufferSize, dataAvailable);
        auto status = multiReader.readWithDomain(dataBuffers.data(), domainBuffers.data(), &count);

        if (status.getReadStatus() == ReadStatus::Event)
        {
            // Set buffer size based on sample rate, allocate buffers
            // Buffers have 100ms worth of memory for each signal
            auto sampleRate = reader::getSampleRate(
                status.getMainDescriptor().getParameters().get(event_packet_param::DOMAIN_DATA_DESCRIPTOR));
            kBufferSize = sampleRate / 10;

            for (size_t i = 0; i < signalsCount; ++i)
            {
                dataBuffers[i] = std::calloc(kBufferSize, getSampleSize(SampleType::Float64));
                domainBuffers[i] = std::calloc(kBufferSize, getSampleSize(SampleType::Int64));
            }
        }
        else if (status.getReadStatus() == ReadStatus::Ok && count > 0)
        {
            std::cout << "Data: ";
            for (const auto& buf : dataBuffers)
                std::cout << std::to_string(static_cast<double*>(buf)[0]) << "; ";
            std::cout << "\n";
        }

        std::this_thread::sleep_for(50ms);
    }
}

----
====

The Multi Reader is created from signals. The first reading returns a list of descriptors, while all subsequent readings use the information extracted from this descriptor list.

== Using the Multi Reader

The Multi Reader has a large suite of configuration options, and its usage patterns vary based on how it is configured. We will start by highlighting a basic example where the reader is use to read data of equal sampling rates and continue with more advanced options.

=== Creating the reader

A set of different factories exist that allow users to create a Multi Reader. In this guide we will mainly be using the `MultiReaderBuilder` factory, as it is the only one that allows for full configuration of parameters, whereas other factories only provide access to a limited set of settings.

==== Basic options

The basic Multi Reader options are as follows:

* *Value read type* - The data type to which value signal data should be converted. If set to `SampleType::Undefined`, data in signal packets will not be converted, but left as-is.
* *Domain read type* - The data type to which domain signal data should be converted. If set to `SampleType::Undefined`, data in signal packets will not be converted, but left as-is.
* *Read mode* - Specifies whether Scaling should be applied. Can also affect the Value read type. Can be one of:
** *Scaled* - Applies Post Scaling, Reference Domain Offset, and calculates Implicit Data Rule on packet data. Output type is equal to Value read type.
** *Unscaled* - Do not apply Post Scaling and Reference Domain Offset do packet data. Data samples output type is equal to Value read type. Unscaled mode works only with Explicit signals
** *Raw* - Same as *Unscaled*, with the exception Value read type being forced to `SampleType::Undefined`. 

==== Signals vs. Ports

Depending on usage, a Multi Reader can be created with signals or input ports as constructor parameters. While similar, there are some differences:

* **Signals**: The Multi Reader creates an internal input port and connects the signal to said port automatically. Users do not have access to the port. Mainly used when an application has a pre-defined list of signals it wants to read.
* **Input Ports**: The port is already created and can be accessed by users. In this case, the Multi Reader takes ownership of the port and waits for signals to be connected. Mainly used in function blocks where users connect signals into a set of pre-created input ports after the function block has been created. 

[tabs]
====
Cpp::
+
[source,cpp]
----
// Creating a reader from signals
auto multiReaderBuilderSignals = daq::MultiReaderBuilder();
for (const auto& signal : signals)
    multiReaderBuilderSignals.addSignal(signal);
auto multiReaderSignals = multiReaderBuilderSignals.build();

// Creating a reader from ports
auto multiReaderBuilderPorts = daq::MultiReaderBuilder();
for (const auto& inputPort : inputPorts)
    multiReaderBuilderPorts.addInputPort(inputPort);
auto multiReaderPorts = multiReaderBuilderPorts.build();
----
====

==== Domain signal requirements

The domain signals of all signals read by the multi reader must fulfil the the following requirements:

* **Domain**: The domain signals must represent time in seconds. The domain unit must have the symbol "s" and the quantity "time".
* **Rule**: The data rule must be linear. 
* **Sampling Rates (SRs)**: All sampling rates must be compatible and measured as an integer number of samples per second. Sample rate (or sampling rate) is the number of samples of a continuous signal taken per domain unit during its conversion into a digital signal. It can be calculated from domain signal decsriptor as stem:[sr = 1 / (r * d)], where `r` - signal `tickResolution`, `d` - signal `linearRule.delta`.
* **Reference Domain Info**: All domain signals can be grouped by pair of reference domain ID and time source. The Multi Reader requires the following:
** At least one of the read signals in a given reference domain ID group must have a known time source, the others can have an unknown source.
** Signals that do not belong to the same reference domain group can still be read together as long as they have a matching time source.
** Signals without a reference domain will be treated as wildcards and the reader will attempt to synchronize them, but might not be successful if the signals are not synchronized.

=== Reading signal descriptors

The first read of the Multi Reader always returns a sample count of 0 and read status `Event` because the Multi Reader provides signal descriptors during the initial read. These can be used to determine the input signal sampling rates, as well as the signal data types. If the descriptor of any read signals changes, the following `read` call will also have the read status `Event`, notifying you of the change.

[tabs]
====
Cpp::
+
[source,cpp]
----
auto dataAvailable = multiReader.getAvailableCount();
auto count = std::min(kBufferSize, dataAvailable);

// Read and check for whether an event was encountered.
auto status = multiReader.readWithDomain(dataBuffers.data(), domainBuffers.data(), &count);
if (status.getReadStatus() == ReadStatus::Event)
{
    std::cout << "Event received\n";
}
----
====

When an event is encountered, the signal descriptors can be obtained from the read status. They can be used to validate signal compatibility with the user application, and used to calculate optimal buffer sizes.

[tabs]
====
Cpp::
+
[source,cpp]
----
if (status.getReadStatus() == ReadStatus::Event)
{
    // Set buffer size based on sample rate (in hertz), allocate buffers
    // Buffers have 100ms worth of memory for each signal
    auto sampleRate = reader::getSampleRate(
        status.getMainDescriptor().getParameters().get(event_packet_param::DOMAIN_DATA_DESCRIPTOR));
    kBufferSize = sampleRate / 10;
}
----
====

If data descriptors do not meet user requirements, the Multi Reader can be deactivated by calling `multiReader.setActive(false)`. While deactivated, the Multi Reader will drop data packets, ensuring it does not run out of memory. Event packets, however, will still be received, allowing users to re-enable the reader if a new, accepted descriptor is set for the input signal.

=== Reading data

After the user has initially read the data descriptors of the packets, it's time to read the data. The Multi Reader returns data in a "jagged array." The allocated memory for the jagged array is provided through a `void**` pointer in the `read()/readWithDomain()` call. The buffers should be allocated to have space for the maximum read amount times the memory size of the data type read. In our example, we read data as `double` and domain data as `int64`. A helper, `daq::getSampleSize`, allowing for calculating the required memory size given a `SampleType` is also provided by openDAQ.

[tabs]
====
Cpp::
+
[source,cpp]
----

if (status.getReadStatus() == ReadStatus::Event)
    // ...

    for (size_t i = 0; i < signalsCount; ++i)
    {
        dataBuffers[i] = std::calloc(kBufferSize, getSampleSize(SampleType::Float64));
        domainBuffers[i] = std::calloc(kBufferSize, getSampleSize(SampleType::Int64));
    }
}
----
====

==== Reading data in a loop

There are two options for reading data with readers: in a loop, or in a callback. When reading data in a loop, the application must provide a thread in which read is called periodically. In the below example, `readWithDomain` is called every 50ms.

[tabs]
====
Cpp::
+
[source,cpp]
----
for (size_t readCount = 0; readCount < 20; readCount++)
{
    auto dataAvailable = multiReader.getAvailableCount();
    auto count = std::min(kBufferSize, dataAvailable);
    auto status = multiReader.readWithDomain(dataBuffers.data(), domainBuffers.data(), &count);

    if (status.getReadStatus() == ReadStatus::Event)
    {
        // ...
    }
    else if (status.getReadStatus() == ReadStatus::Ok && count > 0)
    {
        std::cout << "Data: ";
        for (const auto& buf : dataBuffers)
            std::cout << std::to_string(static_cast<double*>(buf)[0]) << "; ";
        std::cout << "\n";
    }

    std::this_thread::sleep_for(50ms);
}
----
====

==== Reading data in callbacks

To read data in a callback, the multi reader `setOnDataAvailable()` method can be used. When a callback is provided via said method, the callback will be triggered whenever the Multi Reader has data that can be read, or an event has been encountered.

[tabs]
====
Cpp::
+
[source,cpp]
----
auto readData = [&]()
{
    auto dataAvailable = multiReader.getAvailableCount();
    auto count = std::min(kBufferSize, dataAvailable);
    auto status = multiReader.readWithDomain(dataBuffers.data(), domainBuffers.data(), &count);

    if (status.getReadStatus() == ReadStatus::Event)
    {
        // ...
    }
    else if (status.getReadStatus() == ReadStatus::Ok && count > 0)
    {
        std::cout << "Data: ";
        for (const auto& buf : dataBuffers)
            std::cout << std::to_string(static_cast<double*>(buf)[0]) << "; ";
        std::cout << "\n";
    }
};

multiReader.setOnDataAvailable(readData);
----
====

==== Reusing domain data

To simplify the creation of an output domain signals in a function blocks that uses the Multi Reader, the read status provides a "main descriptor" that can be obtained through the `getMainDescriptor()` reader function. In function blocks that aggregate signals (ie. multiplication or summation of signals), the output signal likely has the same sampling rate and timestamps as its inputs. As such, the domain descriptor of the "main signal" can be used as the descriptor for the output domain signal.

NOTE: The main descriptor simply corresponds to the first signal in the list of signals read by the Multi Reader.

[tabs]
====
Cpp::
+
[source,cpp]
----
auto eventPacket = status.getMainDescriptor();
auto outputDomainDescriptor = eventPacket.getParameters().get(event_packet_param::DOMAIN_DATA_DESCRIPTOR);
auto outputDomainSignal = SignalWithDescriptor(context, outputDomainDescriptor, parent, "outputDomainSignal");
----
====

// TODO: Once multi reader supports Explicit rule signals, the following section should be adapted.
As the Multi Reader allows only Implicit rule signals, the output domain packets of the `outputDomainSignal` should contain no buffers, they should only have the `PacketOffset` configured. The reader status `getOffset` function can be used to obtain the `PacketOffset` for output domain signal packet creation.

[tabs]
====
Cpp::
+
[source,cpp]
----
// `count` corresponds to the amount of samples read
auto outputDomainPacket = DataPacket(outputDomainDescriptor, count, status.getOffset());
outputDomainSignal.sendPacket(outputDomainPacket);
----
====

=== Advanced usage

_Comment: Section should explain all multi reader builder parameters that are not explained above_

required common sample rate 
start on full unit of domain
min read count

=== Different sample rates

The case of different sample rates differs from the basic case in several ways:
- The main descriptor and offset from the Multi Reader status are no longer usable, because signals could have different sample rates.
- The output sample count will be different for each signal and should be calculated using dividers.

The divider for a particular signal is calculated as `commonSampleRate / signalSampleRate`. To obtain the common sample rate from the Multi Reader, the user can call the `getCommonSampleRate()` method. However, note that this method will return a value only after the user reads the descriptors for the first time, if the required sample rate was not set before during creation. However, if the required rate is set, the common sample rate will be available right from the Multi Reader creation.

To obtain the signal's sample rate, the user can call `daq::reader::getSampleRate(domainDescriptor)` on the domain descriptor if the signal was returned in the status from the first `read()/readWithDomain()` call.

The user can allocate memory according to the requested number of samples, with the element count equal to `count / divider`, where `count` is the requested number of samples. The user cannot read fewer samples than the least common multiple (LCM) of the dividers of all signals connected to the Multi Reader.

[tabs]
====
Cpp::
+
[source,cpp]
----
auto size = count / divider;
domainBuffers[i] = std::calloc(size, getSampleSize(kDomainSampleType));
dataBuffers[i] = std::calloc(size, getSampleSize(kValueSampleType));
----
====

In the example above `count` is the maximum amount of samples, that could be read from packet. Buffer sizes will be scaled from this amount in according with the dividers. 

== Limitations

* **No Asynchronous Signals**: The Multi Reader does not support asynchronous signals. Only a linear rule is accepted for domain signals.
* **Gap Packets**: Gap packets can only be detected when the reader is created from ports, not directly from signals.
* **Fixed Sample Rates**: Changing input sample rates invalidates the reader, so it is impossible to use Multi Reader if one of the signals sample rate was changed.
* **Additions Post-Creation**: Adding new signals or ports to the reader after creation is not supported.
* **Tick Alignment**: Tick alignment and offsets must adhere to strict rules for synchronization.

== All builder options

* **Min read count**: Specifies the minimal amount of samples that can be read. `getAvailableCount()/read()/readWithDomain()` will return 0, if there are available less samples. Also two last calls will drop samples from the signal queue in case of somebody will try to call them with 0 count, if amount of samples in queue less than min read count.
* **Required common sample rate**: Common sample rate of of the Multi Reader calcualted as the Least Common Multiple (LCM) of all signals sample rates. If common sample rate setup manually, all signal dividers will be calculated according to those sample rate.
* **Start on full unit of domain**: Align commont starting point of all singals to even numbers of domain units from common origin. 
* **Ports vs. Signals**: The Multi Reader can be constructed using input ports or signals, but not a mixture of both.
** *Ports*: Allow detection of gaps between packets.
** *Signals*: Do not support gap detection.

== Signal synchronization

Synchronization of multiple readers refers to identifying a common point in the domain space and beginning to read all signal samples simultaneously from that point or immediately afterward.

Synchronization happens during three Multi Reader calls - `getAvailableCount()` and `read()/readWithDomain()`. But synchronization inside `getAvailableCount()` is not a complete procedure, because during `getAvailableCount()` multireader does not obtain domain samples and only checks sample counts in connection queues, thus makes it impossible to find common starting point. 

To synchronize two signals, the Multi Reader initially needs to read their domain descriptors from the connection queue. This can be achieved by `read()/readWithDomain()` calls. Before this call, `getAvailableCount()` will return 0, and the result of `getCommonSampleRate()` will also be unavailable.

On the first `read()/readWithDomain()` call, the Multi Reader will save the resolution for each signal, set the unsynchronized state, save the origin, and calculate sample rate of the signal and its divider. If the previous sample rate was not undefined and does not equal the new one, the Multi Reader transitions to an invalid state. The common sample rate amoing all signals will be calculated as the least common multiplier (LCM) of the sample rate of each individual signal. If a the required sample rate was configured during reader creation, said rate will be the common one. From the common sample rate, the divider for each individual signal will be calculated. The common sample rate must be divisible by the divider without remainder. If this is not the case, the Multi Reader becomes invalid. Additionally, the LCM of all dividers is calculated for use in aligning the count of available and read samples in `getAvailableCount()` and `read()/readWithDomain()` calls and is used to align the sample count in the `skipSamples()` call.

After event packets are removed from the beginning of the input port queues, synchronization can happen. The earliest origin and highest resolution among all signals are calculated (the system resolution, which runs openDAQ, is also considered as one of the resolutions and often becomes the highest one). Then, for each signal, the offset in maximum resolution ticks from the earliest epoch value is calculated, along with a multiplier, which represents the ratio of the signal resolution to the maximum resolution (stem:["multiplier" = "signal_resolution" / "maximum_resolution"]) and is used to convert signal ticks from the signal resolution to the common maximum resolution: stem:["ticks"_"maximum_resultion" = "ticks"_"signal_resolution" * "multiplier"].

Next, the Multi Reader reads the start domain value of each signal. This includes scaling and applying the reference domain offset (if it was used). The latest domain value among all signals becomes the common starting point from which reading should start. This starting point offset is also rounded up to either an interval, which is defined as the ratio of the LCM of the sample rate dividers to the common sample rate, or to full units of the domain if such an option was used during creation.

When the starting point is found, each signal skips samples up to this point. When the domain value of a signal becomes greater than or equal to this starting point, it is considered synchronized. When all signals are synchronized, the entire Multi Reader state also becomes synchronized.

=== Resynchronization

Resynchronization is triggered by domain descriptor updates or changes in the active state via the `setActive()` call. 
Changes in resolution or origin transfer the signal to an unsynchronized state, while changes in sample rate transfer it to an invalid state.

Resynchronization includes all the steps described in the synchronization process.

=== Drop Conditions

Synchronization is dropped if inputs violate domain or sample rate rules.

== Limitations Summary

* **No Asynchronous Signals**: The Multi Reader does not support asynchronous signals. Only a linear rule is accepted for domain signals.
* **Gap Packets**: Gap packets can only be detected when the reader is created from ports, not directly from signals.
* **Fixed Sample Rates**: Changing input sample rates invalidates the reader, so it is impossible to use Multi Reader if one of the signals sample rate was changed.
* **Additions Post-Creation**: Adding new signals or ports to the reader after creation is not supported.
* **Tick Alignment**: Tick alignment and offsets must adhere to strict rules for synchronization.
* **Domain Offsets**: Add reference domain offsets should have the same time source.

By adhering to these structured guidelines, the Multi Reader ensures robust and synchronized handling of signal data with varying characteristics.

== Full example source

[tabs]
====
Cpp::
+
[source,cpp]
----
#include <opendaq/event_packet_ids.h>
#include <opendaq/event_packet_params.h>
#include <opendaq/opendaq.h>

#include <iostream>

using namespace std::chrono_literals;
using namespace daq;

constexpr auto kSampleCount = SizeT{10};
constexpr auto kDomainSampleType = SampleType::Int64;
constexpr auto kValueSampleType = SampleType::Float64;

struct SignalInfo
{
    IntegerPtr divider;
    RatioPtr resolution;
    StringPtr origin;
};

static inline DataDescriptorPtr getDomainDescriptor(const EventPacketPtr& eventPacket)
{
    auto domainDesc = DataDescriptorPtr();
    if (eventPacket.getEventId() == event_packet_id::DATA_DESCRIPTOR_CHANGED)
        domainDesc = eventPacket.getParameters().get(event_packet_param::DOMAIN_DATA_DESCRIPTOR);
    return domainDesc;
}

static SignalConfigPtr createOutputSignal(const ContextPtr& context, const ComponentPtr& parent, const MultiReaderStatusPtr& status)
{
    auto outputSignal = SignalConfigPtr();
    auto eventPacket = status.getMainDescriptor();
    auto mainDescriptor = getDomainDescriptor(eventPacket);
    if (!mainDescriptor.assigned())
        return outputSignal;

    auto outputDomainDescriptorBuilder = DataDescriptorBuilderCopy(mainDescriptor);
    auto outputDomainDescriptor = outputDomainDescriptorBuilder.setName("OutputDomain").build();

    auto outputDataDescriptorBuilder = DataDescriptorBuilder().setName("OutputData").setSampleType(kValueSampleType);
    auto outputDataDescriptor = outputDataDescriptorBuilder.build();

    auto outputDomainSignal = SignalWithDescriptor(context, outputDomainDescriptor, parent, "outputDomainSignal");
    auto outputDataSignal = SignalWithDescriptor(context, outputDataDescriptor, parent, "outputDataSignal");

    outputDataSignal.setDomainSignal(outputDomainSignal);
    outputSignal = outputDataSignal;

    return outputSignal;
}

static StreamReaderPtr createOutputReader(const SignalConfigPtr& outputSignal)
{
    auto epoch = std::chrono::system_clock::time_point{};
    auto resolution = RatioPtr();
    auto reader = StreamReader(outputSignal, kValueSampleType, kDomainSampleType);
    reader.setOnDataAvailable(
        [reader, epoch, resolution]() mutable
        {
            auto available = reader.getAvailableCount();
            if (available > 0)
            {
                auto domainSamples = std::vector<SampleTypeToType<kDomainSampleType>::Type>(available);
                auto dataSamples = std::vector<SampleTypeToType<kValueSampleType>::Type>(available);
                auto count = available;
                reader.readWithDomain(dataSamples.data(), domainSamples.data(), &count);
                for (auto i = 0; i < count; ++i)
                    fmt::println("[{}] {:<#.5}", reader::toSysTime(domainSamples[i], epoch, resolution), dataSamples[i]);
            }
            else
            {
                auto event = EventPacketPtr();
                auto count = SizeT{0};
                auto status = reader.read(nullptr, &count);
                switch (status.getReadStatus())
                {
                    case ReadStatus::Event:
                        event = status.getEventPacket();
                        if (event.getEventId() == event_packet_id::DATA_DESCRIPTOR_CHANGED)
                        {
                            auto parameters = event.getParameters();
                            if (parameters.hasKey(event_packet_param::DOMAIN_DATA_DESCRIPTOR))
                            {
                                auto domainDataDescriptor =
                                    parameters.get(event_packet_param::DOMAIN_DATA_DESCRIPTOR).asPtr<IDataDescriptor>();
                                auto origin = domainDataDescriptor.getOrigin();
                                epoch = reader::parseEpoch(origin);
                                resolution = domainDataDescriptor.getTickResolution();
                            }
                        }
                        break;
                    case ReadStatus::Ok:
                    case ReadStatus::Fail:
                    case ReadStatus::Unknown:
                        break;
                }
            }
        });

    return reader;
}

static void allocBuffers(const std::vector<SignalInfo>& signalsInfo,
                         std::vector<void*>& dataBuffers,
                         std::vector<void*>& domainBuffers,
                         const SizeT count)
{
    for (SizeT i = 0; i < signalsInfo.size(); ++i)
    {
        auto divider = signalsInfo[i].divider.getValue(1);
        auto size = count / divider;
        domainBuffers[i] = std::calloc(size, getSampleSize(kDomainSampleType));
        dataBuffers[i] = std::calloc(size, getSampleSize(kValueSampleType));
    }
}

template <typename T = SampleTypeToType<kDomainSampleType>::Type, typename V = SampleTypeToType<kValueSampleType>::Type>
static void handleData(const std::vector<SignalInfo>& signalsInfo,
                       const std::vector<void*>& dataBuffers,
                       const std::vector<void*>& domainBuffers,
                       const SizeT count,
                       const SignalConfigPtr& outputDataSignal,
                       const MultiReaderStatusPtr& status,
                       const bool sameSampleRate)
{
    assert(signalsInfo.size() == domainBuffers.size());
    assert(signalsInfo.size() == dataBuffers.size());

    auto avg = std::vector<V>();
    auto lines = std::vector<std::string>(count);

    for (SizeT i = 0; i < signalsInfo.size(); ++i)
    {
        auto divider = signalsInfo[i].divider.getValue(1);

        if (avg.size() != (count / divider))
            avg.resize(count / divider);

        for (SizeT k = 0; k < count / divider; ++k)
        {
            auto* domainBuffer = static_cast<T*>(domainBuffers[i]);
            auto* sampleBuffer = static_cast<V*>(dataBuffers[i]);

            auto& domainValue = domainBuffer[k];
            auto& dataValue = sampleBuffer[k];

            auto epoch = reader::parseEpoch(signalsInfo[i].origin);
            auto resolution = signalsInfo[i].resolution;
            auto timestamp = reader::toSysTime(domainValue, epoch, resolution);

            lines[k] += fmt::format("[{}] {:<#15.5} ", timestamp, dataValue);

            if (sameSampleRate)
                avg[k] = (avg[k] + dataValue) / 2;
        }
    }

    for (const auto& line: lines)
        std::cout << line << std::endl;

    if (outputDataSignal.assigned() && sameSampleRate)
    {
        auto outputDomainSignal = outputDataSignal.getDomainSignal().asPtr<ISignalConfig>();
        auto outputDomainDescriptor = outputDomainSignal.getDescriptor();
        auto outputDataDescriptor = outputDataSignal.getDescriptor();

        auto offset = status.getOffset();
        auto outputDomainPacket = DataPacket(outputDomainDescriptor, avg.size(), offset);
        auto outputDataPacket = DataPacketWithDomain(outputDomainPacket, outputDataDescriptor, avg.size(), offset);
        auto* data = outputDataPacket.getData();
        std::memcpy(data, avg.data(), sizeof(V) * avg.size());

        outputDomainSignal.sendPacket(outputDomainPacket);
        outputDataSignal.sendPacket(outputDataPacket);
    }
}

static std::vector<SignalInfo> handleEvents(const MultiReaderPtr& multiReader,
                                            const DictPtr<IString, IEventPacket>& events,
                                            bool sameSampleRate)
{
    auto signalsInfo = std::vector<SignalInfo>();
    auto commonDivider = IntegerPtr();
    for (const auto& [signalName, event] : events)
    {
        // do something with signal descriptors
        if (event.getEventId() == event_packet_id::DATA_DESCRIPTOR_CHANGED)
        {
            auto parameters = event.getParameters();
            if (parameters.hasKey(event_packet_param::DOMAIN_DATA_DESCRIPTOR))
            {
                auto domainDescriptor = parameters.get(event_packet_param::DOMAIN_DATA_DESCRIPTOR).asPtr<IDataDescriptor>();
                auto sampleRate = reader::getSampleRate(domainDescriptor);
                auto origin = domainDescriptor.getOrigin();
                auto resolution = domainDescriptor.getTickResolution();
                auto divider = Integer(multiReader.getCommonSampleRate() / sampleRate);
                if (!commonDivider.assigned())
                {
                    commonDivider = divider;
                }
                else
                {
                    if (commonDivider != divider)
                        sameSampleRate = false;
                }
                signalsInfo.push_back({divider, resolution, origin});
            }
            if (parameters.hasKey(event_packet_param::DATA_DESCRIPTOR))
            {
                auto dataDescriptor = parameters.get(event_packet_param::DATA_DESCRIPTOR);
                // do something with data desctiptor
                // ...
            }
        }
    }
    return signalsInfo;
}

int main()
{
    auto instance = InstanceBuilder().addModulePath(MODULE_PATH).addModulePath(EXTRA_MODULE_PATH).build();
    auto context = instance.getContext();
    auto devices = instance.getAvailableDevices();
    auto refDevice = DevicePtr();

    for (const auto& device : devices)
    {
        auto connectionString = device.getConnectionString();
        if (connectionString.toStdString().find("daqref://") != std::string::npos)
        {
            refDevice = instance.addDevice(device.getConnectionString());
            std::cout << "Add device " << device.getName() << " - " << device.getConnectionString() << std::endl;
            break;
        }
    }

    if (!refDevice.assigned())
    {
        std::cout << "Reference device not found" << std::endl;
        return EXIT_FAILURE;
    }

    auto signals = refDevice.getSignalsRecursive();
    auto multiReader = MultiReader(signals, kValueSampleType, kDomainSampleType);
    auto domainBuffers = std::vector<void*>(signals.getCount(), nullptr);
    auto dataBuffers = std::vector<void*>(signals.getCount(), nullptr);
    auto signalsInfo = std::vector<SignalInfo>();
    auto running = true;
    auto isSameSampleRate = true;

    auto outputSignal = SignalConfigPtr();
    auto outputReader = StreamReaderPtr();

    auto readData = [&]()
    {
        auto count = kSampleCount;
        auto status = multiReader.readWithDomain(dataBuffers.data(), domainBuffers.data(), &count);
        switch (status.getReadStatus())
        {
            case ReadStatus::Ok:
                handleData(signalsInfo, dataBuffers, domainBuffers, count, outputSignal, status, isSameSampleRate);
                break;
            case ReadStatus::Event:
                signalsInfo = handleEvents(multiReader, status.getEventPackets(), isSameSampleRate);
                allocBuffers(signalsInfo, dataBuffers, domainBuffers, kSampleCount);
                outputSignal = createOutputSignal(context, nullptr, status);
                outputReader = createOutputReader(outputSignal);
                break;
            case ReadStatus::Fail:
            case ReadStatus::Unknown:
                running = false;
                break;
        }
    };
    multiReader.setOnDataAvailable(readData);

    while (running)
        std::this_thread::sleep_for(10ms);

    return 0;
}
----
====